Test In The Demo Environment
For testing purposes, Kalshi offers a demo environment with mock funds. You can access the Demo environment at https://demo.kalshi.co/. For safety, credentials are not shared between this environment and production.

To create an account on demo, sign up here. Then follow these steps to obtain a trading balance.

Demo's API root ishttps://demo-api.kalshi.co/trade-api/v2.

API Keys
API Key usage

This process is the same for the demo or production environment.

Generating an API Key
Access the Account Settings Page:**
Log in to your account and navigate to the “Account Settings” page. You can typically find this option by clicking on your profile picture or account icon in the top-right corner of the application.

Generate a New API Key
In the “Profile Settings” page https://kalshi.com/account/profile, locate the “API Keys” section. Click on the “Create New API Key” button. This action will generate a new API key in the RSA_PRIVATE_KEY format.

Store Your API Key and Key ID:
After generating the key, you will be presented with:
• Private Key: This is your secret key in RSA_PRIVATE_KEY format.
• Key ID: This is a unique identifier associated with your private key.

Important: For security reasons, the private key will not be stored by our service, and you will not be able to retrieve it again once this page is closed. Please make sure to securely copy and save the private key immediately. The key will also be downloaded as txt file with the name provided.

Using a API Key **
Each request to Kalshi trading api will need to be signed with the private key generated above.

The following header values will need to be provided with each request:

KALSHI-ACCESS-KEY- the Key ID

KALSHI-ACCESS-TIMESTAMP - the request timestamp in ms

KALSHI-ACCESS-SIGNATURE- request hash signed with private key

The above signature is generated by signing a concatenation of the timestamp, the HTTP method and the path.

Sample code for generating the required headers is below (alternatively use our example code here):

Python

Load the private key stored in a file


from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

def load_private_key_from_file(file_path):
    with open(file_path, "rb") as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password=None,  # or provide a password if your key is encrypted
            backend=default_backend()
        )
    return private_key
Sign text with private key


import base64
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.exceptions import InvalidSignature

def sign_pss_text(private_key: rsa.RSAPrivateKey, text: str) -> str:
    # Before signing, we need to hash our message.
    # The hash is what we actually sign.
    # Convert the text to bytes
    message = text.encode('utf-8')



    try:
        signature = private_key.sign(
            message,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.DIGEST_LENGTH
            ),
            hashes.SHA256()
        )
        return base64.b64encode(signature).decode('utf-8')
    except InvalidSignature as e:
        raise ValueError("RSA sign PSS failed") from e
Send request


import requests
import datetime

# Get the current time
current_time = datetime.datetime.now()

# Convert the time to a timestamp (seconds since the epoch)
timestamp = current_time.timestamp()

# Convert the timestamp to milliseconds
current_time_milliseconds = int(timestamp * 1000)
timestampt_str = str(current_time_milliseconds)

# Load the RSA private key
private_key = load_private_key_from_file('kalshi-key-2.key')

method = "GET"
base_url = 'https://demo-api.kalshi.co'
path='/trade-api/v2/portfolio/balance'


msg_string = timestampt_str + method + path

sig = sign_pss_text(private_key, msg_string)

headers = {
        'KALSHI-ACCESS-KEY': 'a952bafb-12dd-4955-9e7c-3895265e812d',
        'KALSHI-ACCESS-SIGNATURE': sig,
        'KALSHI-ACCESS-TIMESTAMP': timestampt_str
    }
response = requests.get(base_url + path, headers=headers)
print("Status Code:", response.status_code)
print("Response Body:", response.text)

JS


const fs = require('fs');
const crypto = require('crypto');
const axios = require('axios');

function loadPrivateKeyFromFile(filePath) {
    const keyData = fs.readFileSync(filePath, 'utf8');
    const privateKey = crypto.createPrivateKey({
        key: keyData,
        format: 'pem',
        // If your key is encrypted, you'd need to provide a passphrase here
        // passphrase: 'your-passphrase'
    });
    return privateKey;
}

function signPssText(privateKey, text) {
    // Before signing, we need to hash our message.
    // The hash is what we actually sign.
    // Convert the text to bytes
    const message = Buffer.from(text, 'utf-8');

    try {
        const signature = crypto.sign(
            'sha256',
            message,
            {
                key: privateKey,
                padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
            }
        );
        return signature.toString('base64');
    } catch (error) {
        throw new Error("RSA sign PSS failed: " + error.message);
    }
}

// Get the current time
const currentTime = new Date();

// Convert the time to a timestamp (milliseconds since the epoch)
const currentTimeMilliseconds = currentTime.getTime();
const timestampStr = currentTimeMilliseconds.toString();

// Load the RSA private key
const privateKey = loadPrivateKeyFromFile('baseKey.txt');

const method = "POST";
const baseUrl = 'https://demo-api.kalshi.co';
const path = '/trade-api/v2/portfolio/orders';
const body = {"action": "buy", "client_order_id": "1fa1be86-3f8e-49be-8c1e-1e46ea490d59", "count": 3, "side": "yes", "ticker": "HOMEUSY-24-T4", "type": "limit", "yes_price": 30};

const msgString = timestampStr + method + path;

console.log(msgString);

const sig = signPssText(privateKey, msgString);

const headers = {
    'KALSHI-ACCESS-KEY': '164c4e3e-f653-4847-b962-bc4975b91ddc',
    'KALSHI-ACCESS-SIGNATURE': sig,
    'KALSHI-ACCESS-TIMESTAMP': timestampStr,
    'Content-Type': 'application/json'
};

axios.post(baseUrl + path, body, { headers })
    .then(response => {
        console.log("Status Code:", response.status);
        console.log("Response Body:", response.data);
    })
    .catch(error => {
        console.error("Error:", error.message);
        console.log(error.response.data);
    });

Rate Limits and Tiers
Access tiers:
Tier	Read	Write
Basic	10 per second	5 per second
Advanced	30 per second	30 per second
Premier	100 per second	100 per second
Prime	100 per second	400 per second
Qualification for tiers
Basic: Completing signup
Advanced: Completing https://forms.gle/iMhGvPZ1yU173jk2A
Premier: 3.75% of exchange traded volume in a given month
Prime: 7.5% of exchange traded volume in a given month
In addition to the volume targets, technical competency is a requirement for Premier/Prime access. Before providing access to the Premier/Prime tiers, the Exchange will establish that the trader/trading entity has the following requirements met:
Knowledge of common security practices for API usage.
Proficiency in setting up monitoring for API usage, and ability to monitor API usage in near real-time.
Understanding and implementation of rate limiting and throttling mechanisms imposed by the API, and the ability to self-limit load.
Awareness of legal and compliance aspects related to API usage.
Only the following APIs fall under the write limit, for the batch APIs, each item in the batch is considered 1 transaction with the sole exception of BatchCancelOrders, where each cancel counts as 0.2 transactions.
BatchCreateOrders
BatchCancelOrders
CreateOrder
CancelOrder
AmendOrder
DecreaseOrder
We reserve the right to downgrade your API rate limit tier from Prime and Premier when you have shown lack of activity in the previous period
Kalshi Glossary
Here are some core terminologies used in Kalshi exchange

Market:A single binary market. This is a low level object which rarely will need to be exposed on its own to members. The usage of the term “market” here is consistent with how it’s used in the backend and API.
Event: An event is a collection of markets and the basic unit that members should interact with on Kalshi.
Series:A series is a collection of related events. The following should hold true for events that make up a series:
Each event should look at similar data for determination, but translated over another, disjoint time period.
Series should never have a logical outcome dependency between events.
Events in a series should have the same ticker prefix.
Please see the "Timeline and Payout" dropdown on a market's page to find the Market, Event, and Series tickers. Note that the market ticker will depend on which market you are looking at on that page. For example, Trump and Harris are each their own market.


Market Data Feed
Receive websockets notifications for updates on Kalshi.

Protocol overview
Our websockets api is only served over an encrypted connection.

There is a single endpoint to establish WS connections: wss://api.elections.kalshi.com/trade-api/ws/v2.

We provide multiple channels of information over a single connection. So after establishing a WS connection, the client has the freedom to chose which channels they are interested in at any given moment. To express the intention of receiving messages for a specific channel the client has to send subscription messages that will be defined latter on in this document.

This endpoint only can be used by signed-up users (private channels only).

The communication between the user (client) and Kalshi's backend (server) is async. All the messages exchanged should be encoded in JSON format.

We call messages in the client -> server direction commands, these commands specify the set of message types and specific markets the client is interested on.

Typically, the client starts the connection and sends commands to the server and eventually receives messages related to the commands whenever there is an update on the server.

Example:


(cli => srv)
(srv => cli)

=> cmd1
=> cmd2
<= msg_related_to_cmd_2
<= msg_related_to_cmd_1
<= msg_related_to_cmd_2
...
Connecting
You can connect to our PROD websocket api at wss://api.elections.kalshi.com/trade-api/ws/v2 by using API key authentication.

Note that since user-password authentication is no longer supported the /trade-api/v2/login endpoint is not needed when connecting to the websocket api.

Commands
The initial version of the protocol provides only subscription commands.

Eventually, we may want to offer a complete trading API through WebSocket, but, for now, you should continue using the REST API for trading, while the WS interface provides a stream of notifications/updates.

Without WS, you would have to be constantly polling the GET end-points from api v2 to keep yourself up to date with what is going on in the markets.

Each command uses the following format:

JSON

{
	"id": <int>,     // Unique ID of the command request.
	"cmd": <string>, // Command name: "subscribe" or "update_subscription" or "unsubscribe".
	"params": {...}  // Params that are specific to the given cmd.
}
Given that our protocol is async, we use the id field to correlate commands with further data messages from the server. When the client includes an id in a command, the server returns that id value in messages related to that command, just so you could recognize them in the message stream. The id is generated by the client and should be unique within a WS session.

The simplest way to use it would be to start from 1 and then increment the value for every new command sent to the server. If the id is set to 0, the server treats it the same way as if there was no id.

Command "subscribe"
Subscription to one or many channels. Example:

JSON

{"id": 1,"cmd": "subscribe","params": {"channels": ["orderbook_delta", "ticker"], "market_ticker": "CPI-22DEC-TN0.1"}}
If the subscription is successful, the client will receive a separate "subscribed" message for each channel in the "channels" param field of the "subscribe" message. These are confirmation messages to indicate that the subscription was accepted successfully. The order of those messages is not guaranteed, as the protocol is async.

Note that the ID will be the same in both message, as they "respond" to the same command.

JSON
JSON

{
	"id": 1,
	"type": "subscribed",
	"msg": {
		"channel": "orderbook_delta",
		"sid": 1
	}
}
Important notes:

You can only subscribe a single time to any channel.
Some channels support subscribing to all markets, which is indicated by not passing any market ticket (more details will be provided in next sections).
If you retry the subscription message in the beginning of this section, but using "id": 2. Then you should get the error below as a response:

JSON

{"type":"error","id":2,"msg":{"code":6,"msg":"Already subscribed"}}
Each established subscription is identified by another ID (sid) returned by the server.

This subscription ID can later be used by the client to cancel the subscription (equals to unsubscribe) or to update the subscription adding or removing markets.

The subscription id (sid) is also used in messages sent by the server within each subscription so you can identify which message belong to which subscription when you receive them.

One or both of the subscription attempts can fail. For every failure, the server returns an error message, the format of which is described later on this page.

Subscription Modes
The subscribe command allows for three different subscription modes:

All markets: Do not pass "market_ticker" or "market_tickers". You will get all fills for you account.
List of markets: Pass the list of markets on "market_tickers". You will get updates only for this list of markets.
Single market: Pass a single market ticker on "market_ticker". You will get updates only for this market.
Important notes:

Availability of the "All markets" mode will depend on the specific channel, this is disclosed in the specific channel sections latter on.
When the "All markets" mode is supported it will automatically track new markets that happen to open after your subscription was initiated.
Command "unsubscribe"
The client can cancel more than one or more subscriptions at once:

JSON

{"id": 124,"cmd": "unsubscribe","params": {"sids": [1, 2]}}
Confirmation messages are sent to the client independently, and, again, the order is not guaranteed:

JSON
JSON

{
	"sid": 2,
	"type": "unsubscribed"
}
Command "update_subscription"
The client can update an existing subscription. The update action should be specified in params in the “action” field.

All the channels (besides the "fill" channel) allow updates and supports two types of actions: add_markets and delete_markets.

Updating a subscription to include new markets is preferred over starting new subscriptions.

JSON

{
	"id": 124,
	"cmd": "update_subscription",
	"params": {
		"sids": [456], // Exactly one sid is required, even though it is an array
		"market_tickers": ["<string>", ..., "<string>"], // market_ticker is also supported for a single market
		"action": "add_markets|delete_markets"
	}
}
In case of success an "ok" message will be received containing the list of market tickers after the update:

JSON

{
	"id": 123,
	"sid": 456,
	"seq": 222,
	"type": "ok",
    "market_tickers": ["<string>", ..., "<string>"] // full list of market_tickers this subscription is tracking
}
Client-Side Recovery
The client should handle unexpected behavior in the following manner:

Connection Closed:
Attempt to reconnect periodically. After successful reconnect, immediately resubscribe to all previously subscribed channels. Also, re-send all subscription commands from before the disconnection.
Server-Forced Unsubscription
Immediately attempt to re-subscribe to channel. If response is an error, handle it .
Subscribe Command Not Confirmed by Server
If the client does not receive a confirmation during a predefined window, it should close the connection and attempt to reconnect.
Connection Health Deteriorates
At any indication of an unhealthy connection, the client will close the connection and attempt to reconnect as described above.
Server messages
All specific message types are described in detail below and later in the "Subscription Channels" section.

Server message format
This section describes the general structure of messages.

The fields market as Required should be sent when responding to client commands or sending messages in subscription channels.

JSON

{
	"id": <int>,      // Optional command ID
	"sid": <int>,     // Optional subscription ID (described below)
	"seq": <int>,     // Optional sequence number (described below)
	"type": <string>, // Required message type (described below)
	"msg": {...}      // Required body of the message
}
The id field is optional and only included in a server message if the client provided it in the corresponding command.

When a channel subscription is established, messages within the channel will not have the id field. Instead, we use sid to identify the channel.

Error messages
Sometimes commands can't be executed on the server.

For example, a client cannot subscribe to a channel if the client is already subscribed to that channel (besides the fill channel where that is allowed). Or, symmetrically, it's impossible to cancel a non-existent subscription.

Here is an example error message that the server returns upon an attempt to open a second subscription to the same channel:

JSON

{
	"id": 123,
	"type": "error",
	"msg": {
		"code": 6,
		"msg": "Already subscribed"
	},
}
Subscription Channels
A subscription channel is a feed of logically related messages. It can include, for example, all trades on a specific market, or all orderbook offers on a specific market.

We are free to define channels and their logic however we see fit. Though, it's easier to reason about a channel if its purpose is clearly defined.

Below is a provisional list of channels. New channels will be added progressively.

Channels for a signed in user:

orderbook_delta: price level updates on a market.
ticker: market price ticks.
trade: public trades.
fill: user fills.
Important observation: We standardize the channels with singular name form.

If you try to subscribe to an unexisting channel you should receive this message:

JSON

{
	"id": 123,
	"type": "error",
	"msg": {
		"code": 8,
		"msg": "Unknown channel name"
	},
}
Snapshot + Deltas
Some channels have to provide data in a highly reliable way so that the client could build a correct and consistent view from the received messages at any time.

Take, for example, the orderbook_delta channel (which is going to be detailed in the next section). There are two types of messages that can be received from the server in an orderbook_delta subscription.

A "snapshot": a complete view of the order book.
A "delta": an update to be applied to the current view of the order book.
Any missed "delta" message can result in a wrong state of the world on the client. To avoid the problem, we use sequential numbering for all snapshots and updates. The number is included as seq field in every message.

The server ensures that, within a channel, messages are sent strictly sequentially. So the client would receive the snapshot in a message with seq: 1, then an update message with seq: 2, then all other updates with seq values 3, 4, 5, etc. When the client detects a gap in the numbering, it has to re-subscribe to the channel and start again from a snapshot. Otherwise, the client might see wrong info.

If we don't need a snapshot for a particular channel and don't care if any message is accidentally lost, then you don't have to use the seq feature. Whether a channel is seq-enabled or not will be explicitly noted below.

Order Book channel
Channel: orderbook_delta

Purpose: A complete view of the order book's aggregated price levels on a given market and all further updates to it.

Subscription command (client => server)

Schema:

JSON

{
	"id": <int>, // Required: Sequential command id maintained by the client.
	"cmd": "subscribe", // Required: Specifies the subscription operation.
	"params": {
		"channels": ["orderbook_delta"], // Required: Specifies the orderbook_delta channel.
		"market_tickers": ["<string>", "<string>", ...] // Required: Specifies the list of markets you wanna listen to.
    }
}
This channel does not support the "All Markets" mode, it only supports "List of Markets" mode. So you always have to pass the list of markets you are subscribing to.

Example:

JSON

{"id": 23,"cmd": "subscribe","params": {"channels": ["orderbook_delta"], "market_tickers": ["FED-23DEC-T3.00", "CORIVER-2024-T1030"]}}
After the subscription is established, first, the client receives a snapshot. An example for the orderbook_snapshot message is shown below:

Ordebook snapshot message (server => client)

Schema:

JSON

{
	"sid": <int>, // Required: Id of the subscription.
	"type": "orderbook_snapshot", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
	"seq": 1, // Required: Sequential number, should be checked if you wanna guarantee you received all the messages.
	"msg": {
        "market_ticker": <string>, // Required: Market_ticker string, what you use to differentiate updates for different markets.
		"yes": [ 
			// Optional: This key will not exist if there is no Yes offers in the orderbook.
			// In case it exists there will be many price levels, so for compactness, every element in the list is 
			// an array, with two integers not an object.
			[<int>, <int>], // [Price in cents, Number of resting contracts]
			...        
			[<int>, <int>]
		],
		"no": [ 
			... // Optional. Same format as "yes" but for the NO side of the orderbook.
		]
	}
}
Example:

JSON

{
	"type": "orderbook_snapshot",
	"sid": 2,
	"seq": 2,
	"msg": {
		"market_ticker": "FED-23DEC-T3.00",
		"yes": [
			[8, 300],
			[22, 333]
		],
		"no": [
			[54, 20],
			[56, 146]
		]
	}
}
The client is expected to store the orderbook_snapshot and then keep listening for incoming "orderbook_delta" messages.

Orderbook delta message (server => client)

Schema:

JSON

{
	"type": "orderbook_delta", // Required: Message identifier, what you use to recognize the message type for messages that arrive in your websocket connection.
	"sid": <int>, // Required: Id of the subscription.
	"seq": <int>, // Required: Sequential number, should be checked if you wanna guarantee you received all the messages.
	"msg": {
		"market_ticker": <string>, // Required: Market_ticker string, what you use to differentiate updates on different markets.
		"price": <int>, // Required: Indicates the price level that is being changed in cents
		"delta": <int>, // Required: Positive means increase, negative means decrease
		"side": <string> // Required: "yes" or "no" to indicate the side of the orderbook that changed
	}
}
Example:

JSON

{
	"type": "orderbook_delta",
	"sid": 2,
	"seq": 3,
	"msg": {
		"market_ticker": "FED-23DEC-T3.00",
		"price": 96,
		"delta": -54,
		"side": "yes"
	}
}
The message above signals that the number of resting contracts at price 23 for Yes contracts on this market is now 88 contracts, which is 100 - 22.

Important note: You should still be tracking "orderbook_snapshot" messages as the subscription can update the server can resend the full state of the orderbook in case there are multiple changes at the same avoid. It can pack multiple delta messages in a single "orderbook_snapshot" message. In that case you should throw away whatever view of the orderbook you had and use the content of the message as the current state.

Ticker channel
Channel: ticker

Purpose: The list price ticker for a given market.

No snapshot is required. The server just sends the last price on the market when the price changes. On an active market, when the price changes a few times per second, only the most recent change is sent for that second.

Subscription command (client => server)

Schema:

JSON

{
	"id": <int>, // Required: Sequential command id maintained by the client.
	"cmd": "subscribe", // Required: Specifies the subscription operation.
	"params": {
		"channels": ["ticker"], // Required: Specifies the ticker channel.
		"market_tickers": ["<string>", ..., "<string>"] // Not required: If you do not pass this field it will subscribe to ticker updates on all markets. If you do it will only send updates for the list of markets provided.
	}
}
This channel supports two subscription modes:

List of markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["ticker"],
		"market_tickers": ["FED-23DEC-T3.00", "CORIVER-2024-T1030"]
	}
}
All markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["ticker"],
	}
}
Ticker message (server => client)

A message with a ticker update from the server:

Schema:

JSON

{
	"type": "ticker", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
 	"sid": <int>, // Required: Id of the subscription.
 	"msg": {
		"market_ticker": <string>, // Required: Market_ticker string, what you use to differentiate updates for different markets.
		"price": <int>, // Between 1 and 99 (inclusive)
		"yes_bid": <int>, // Between 1 and 99 (inclusive)
		"yes_ask": <int>, // Between 1 and 99 (inclusive)
		"volume": <int>, // Number of individual contracts traded on the market so far YES and NO count separately
		"open_interest": <int>, // Number of active contracts in the market currently
		"dollar_volume": <int>, // Number of dollars traded in the market so far
		"dollar_open_interest": <int>, // Number of dollars positioned in the market currently
		"ts": <int> // Unix timestamp for when the update happened (in seconds)
	}
}
Example:

JSON

{
	"type": "ticker",
	"sid": 11,
	"msg": {
		"market_ticker": "FED-23DEC-T3.00",
		"price": 48,
		"yes_bid": 45,
		"yes_ask": 53,
		"volume": 33896,
		"open_interest": 20422,
		"dollar_volume": 16948,
		"dollar_open_interest": 10211,
		"ts": 1669149841
	}
}
A ticker message also will be sent whenever there is a new trade or the bid / ask values move on any of the markets tracked by the subscription.

Trade channel
Channel: trade

Purpose: Update the client with the most recent trades that occur in the markets that the client is interested on.

The subscription process is similar to the ticker channel, the client subscription specifying the market_tickers he is interested on and the server will start sending trade data messages.

Subscription command (client => server)

Schema:

JSON

{
	"id": <int>, // Required: Sequential command id maintained by the client.
	"cmd": "subscribe", // Required: Specifies the subscription operation.
	"params": {
		"channels": ["trade"], // Required: Specifies the trade channel.
		"market_tickers": [<string>, ..., <string>]   // Not required: If you do not pass this field it will subscribe to trade updates on all markets. If you do it will only send updates for the list of markets provided.
	}
}
This channel supports two subscription modes:

List of markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["trade"],
		"market_tickers": ["FED-23DEC-T3.00", "HIGHNY-22DEC23-B53.5"]
  	}
}
All markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["trade"]
  	}
}
Trade message (server => client)

A trade message will be sent for each trade that happens on the server for the markets included in the subscription. Regardless of whether you participated in the trade or not, this channel exposes public trades.

For security reason, fields that could be used to potentially identify the users or orders involved in the trades like user, order or trade ids are intentionally removed from the response.

Each trade message is equivalent to an entry in the GetTrades endpoint from the trade api.

Schema:

JSON

{
	"type": "trade", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
 	"sid": <int>, // Required: Id of the subscription.
 	"msg": {
		"market_ticker": <string>, // Ticker for the market that this trade belongs to. This is what you use to differentiate updates for different markets.
		"yes_price": <int>, // Price for the yes side. Between 1 and 99 (inclusive).
		"no_price": <int>, // Price for the no side. Between 1 and 99 (inclusive).
		"count": <int>, // Number of contracts traded.
		"taker_side": <string>, // Side of the taker user on this trade. Either "yes" or "no".
		"ts": <int> // Unix timestamp for when the update happened (in seconds).
	}
}
Example:

JSON

{
	"type": "trade",
	"sid": 11,
	"msg": {
		"market_ticker": "HIGHNY-22DEC23-B53.5",
		"yes_price": 36,
		"no_price": 64,
		"count": 136,
		"taker_side": "no",
		"ts": 1669149841
	}
}
Fill channel
Channel: fill

Purpose: Update the client with the most recent fills, that means trades in that occur in the markets that the client is interested on.

The subscription process is similar to the ticker channel, the client subscription specifying the market_tickers he is interested on and the server will start sending trade data messages.

Subscription command (client => server)

Schema:

JSON

{
	"id": <int>, // Required: Sequential command id maintained by the client.
	"cmd": "subscribe", // Required: Specifies the subscription operation.
	"params": {
		"channels": ["fill"], // Required: Specifies the fill channel.
		"market_ticker": <string>,  // Not required: If you do not pass this field it will. If you do it specifies a single market to be subscribed to.
		"market_tickers": <string> // Not required: If you do not pass this field it will subscribe to ticker updates on all markets. If you do it will only send updates for the list of markets provided.
	}
}
This channel supports all subscription modes:

Single market mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["fill"],
		"market_ticker": "CPI-22DEC-TN0.1"
	}
}
List of markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["fill"],
		"market_tickers": ["CPI-22DEC-TN0.1", "INXY-23DEC29-T2700"]
	}
}
All markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["fill"]
	}
}
Fill message (server => client)

A fill message will be sent for each trade that happens for your account on the server limited to the markets that are included in the subscription.

Since this channel is private it will have all the identifiers so you can uniquely recognize each trade.

Each fill message is equivalent to an entry in the GetFills endpoint from the trade api.

Schema:

JSON

{
	"type": "fill", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
 	"sid": <int>,   // Required: Id of the subscription.
 	"msg": {
		"trade_id": <string>, // Unique identifier for fills. This is what you use to differentiate fills.
		"order_id": <string>, // Unique identifier for orders. This is what you use to differentiate fills for different orders.
		"market_ticker": <string>, // Unique identifier for markets. This is what you use to differentiate fills for different markets.
		"is_taker": <bool>, // If you were a taker on this fill.
		"side": <string>, // Side of your fill. Either "yes" or "no".
		"yes_price": <int>, // Price for the yes side of the fill. Between 1 and 99 (inclusive).
		"no_price": <int>, // Price for the no side of the fill. Between 1 and 99 (inclusive).
		"count": <int>, // Number of contracts filled.
		"action": <string>, // Action that initiated the fill. Either "buy" or "sell".
		"ts": <int> // Unix timestamp for when the update happened (in seconds).
	}
}
Example:

JSON

{
	"type": "fill",
	"sid": 13,
	"msg": {
		"trade_id": "d91bc706-ee49-470d-82d8-11418bda6fed",
		"order_id": "ee587a1c-8b87-4dcf-b721-9f6f790619fa",
		"market_ticker": "HIGHNY-22DEC23-B53.5",
		"is_taker": true,
		"side": "yes",
		"yes_price": 75,
		"no_price": 25,
		"count": 278,
		"action": "buy",
		"ts": 1671899397
	}
}
Market Lifecycle channel
Channel: market_lifecycle

Purpose: Update the client with new market lifecycle events of the following types: open, pause, close, determination and settlement with corresponding details for each event.

Subscription command (client => server)

Schema:

JSON

{
	"id": <int>, // Required: Sequential command id maintained by the client.
	"cmd": "subscribe", // Required: Specifies the subscription operation.
	"params": {
		"channels": ["market_lifecycle"] // Required: Specifies the market lifecycle channel.
	}
}
This channel only supports the All markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["market_lifecycle"]
	}
}
market_lifecycle message (server => client)

A market_lifecycle message will be sent for every market on each of the following events:

When a new market is created. For this case, an additional field named additional_metadata containing the market metadata will be emitted.
The fields here directly map to the ones in They directly map to the fields on https://trading-api.readme.io/reference/getmarket
When a market's trading is paused
When a market's close date is updated (early close)
When a market is determined
When a market is settled
Schema:

JSON

{
	"type": "market_lifecycle", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
 	"sid": <int>,   // Required: Id of the subscription.
 	"msg": {
		"market_ticker": <string>, // Unique identifier for markets. This is what you use to differentiate updates for different markets.
		"open_ts": <int>, // Unix timestamp for when the market opened (in seconds).
		"close_ts": <int>, // Unix timestamp for when the market is scheduled to close (in seconds). Will be updated in case of early determination markets.
		"determination_ts": <int>, // Optional: This key will not exist before the market is determined. Unix timestamp for when the market is determined (in seconds).
		"settled_ts": <int>, // Optional: This key will not exist before the market is settled. Unix timestamp for when the market is settled (in seconds).
		"result": <string>, // Optional: This key will not exist before the market is determined. Result of the market.
		"is_deactivated": <bool>, // Boolean flag to indicate if trading is paused on an open market. This should only be interpreted for an open market.
		"additional_metadata": { // Optional: This key will only be emitted when the market is created.
			"name": <string>, 
			"title": <string>,
			"yes_sub_title": <string>,
			"no_sub_title": <string>,
			"rules_primary": <string>,
			"rules_secondary": <string>,
			"can_close_early": <bool>,
			"expected_expiration_ts": <int>,
			"strike_type": <string>,
			"floor_strike": <string>,
			"cap_strike": <bool>,
			"custom_strike": <object>,    
        }    
    }
}
Example:

JSON

{
	"type": "market_lifecycle",
	"sid": 13,
	"msg": {
		"market_ticker": "INXD-23SEP14-B4487", 
		"open_ts": 1694635200,
		"close_ts": 1694721600,
		"determination_ts": 1694722100,
		"settled_ts": 0,
		"result": "no",
		"is_deactivated": false
    }
}
event_lifecycle message (server => client)

An event_lifecycle message will be sent for when the event is created.

Schema:

JSON

{
	"type": "event_lifecycle", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
 	"sid": <int>,   // Required: Id of the subscription.
 	"msg": {
		"event_ticker": <string>, // Unique identifier for the event being created.
		"title": <string>, // Title of event
		"sub_title": <string>, // Subtitle of event
		"collateral_return_type": <string>, // Collateral return type, MECNET or DIRECNET of the event. Empty if there is no collateral return scheme for the event.
		"series_ticker": <string>, // Series ticker for the event.
		"strike_date": <int> // Optional: String to indicate the strike period of the event if there is one.
		"strike_period": <string> // Optional: String to indicate the strike period of the event if there is one.
    }
}
Example:

JSON

{
	"type": "event_lifecycle",
	"sid": 5,
	"msg": {
		"event_ticker": "INXD-23SEP14", 
		"title": "INX title",
		"sub_title": "INX subtitle",
		"collateral_return_type": "DIRECNET",
		"series_ticker": "INXD",
		"strike_date": 1694721600
    }
}
Multivariate channel
Channel: multivariate

Purpose: Update the client with new multivariate collection lookups

Subscription command (client => server)

Schema:

JSON

{
	"id": <int>, // Required: Sequential command id maintained by the client.
	"cmd": "subscribe", // Required: Specifies the subscription operation.
	"params": {
		"channels": ["multivariate"] // Required: Specifies the multivariate channel.
	}
}
This channel only supports the All markets mode:

JSON

{
	"id": 2,
	"cmd": "subscribe",
	"params": {
		"channels": ["multivariate"]
	}
}
multivariate_lookup message (server => client)

A multivariate_lookup message will be sent whenever there is a lookup on a multivariate market. Note that this channel is eventually consistent with the
market_lifecycle channel. The first time a lookup is recorded, you might receive the lookup message before the market_lifecycle message that corresponds to
the market creation.

Schema:

JSON

{
	"type": "multivariate_lookup", // Required: Message identifier, what you use to recognize this message type that arrive in your websocket connection.
 	"sid": <int>,   // Required: Id of the subscription.
 	"msg": {
		"collection_ticker": <string>,
		"event_ticker": <string>,
		"market_ticker": <string>, 
		"selected_markets": [
			{
				"event_ticker": <string>,
				"event_ticker": <string>,
				"side": <string>,
			}
        ]    
    }
}
Example:

JSON

{
	"type": "multivariate_lookup",
	"sid": 13,
	"msg": {
		"collection_ticker": "KXOSCARWINNERS-25",
		"event_ticker": "KXOSCARWINNERS-25C0CE5",
		"market_ticker": "KXOSCARWINNERS-25C0CE5-36353",
		"selected_markets": [
			{
				"event_ticker": "KXOSCARACTO-25",
				"market_ticker": "KXOSCARACTO-25-AB",
				"side": "yes"
			},
			{
				"event_ticker": "KXOSCARACTR-25",
				"market_ticker": "KXOSCARACTR-25-DM",
				"side": "yes"
			},
			{
				"event_ticker": "KXOSCARANIMATED-25",
				"market_ticker": "KXOSCARANIMATED-25-TWR",
				"side": "yes"
			}
		]
	}
}
Heartbeats
We need a way to detect broken connections both on the client and the server sides. The WS protocol has standard ping/pong frames specifically for this purpose.

Server-side:
The server will send PING messages every 10 seconds to check for the connectivity with your client. Your client should respond with a PONG message or else the connection will be dropped on the server side.

Client-side:
The client should also send PING messages every 10 seconds to avoid trusting a stale connection in the client side. The programming languages usually support enabling heartbeat in the client, in such a way that you don't have to write the heartbeat messages yourself, if your programming language supports this we recommend that you enable it in order to have a reliable connection.

For reference
The Websocket Protocol (RFC 6455)
Websocat CLI Tool


GetApiVersion
get
https://api.elections.kalshi.com/trade-api/v2/api_version
Endpoint for getting the current API version.

Response

200
Updated about 1 month ago

Market Data Feed
communications
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/api_version"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)



GetCommunicationsID
get
https://api.elections.kalshi.com/trade-api/v2/communications/id
Endpoint for getting the communications ID of the logged-in user.

Responses

200

403
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

GetApiVersion
GetQuotes
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/id"
4
​
5
response = requests.get(url)
6
​
7
print(response.text)



GetQuotes
get
https://api.elections.kalshi.com/trade-api/v2/communications/quotes
Endpoint for getting quotes

Query Params
cursor
string
limit
int32
market_ticker
string
event_ticker
string
status
string
quote_creator_user_id
string
rfq_creator_user_id
string
rfq_id
string
Responses

200

400
Generic structure for API error responses.


403
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

GetCommunicationsID
CreateQuote
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/quotes"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)



CreateQuote
post
https://api.elections.kalshi.com/trade-api/v2/communications/quotes
Endpoint for creating a quote in response to an RFQ

Query Params
rfq_id
string
yes_bid
int64
no_bid
int64
rest_remainder
boolean

Responses

201

400
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

GetQuotes
GetQuote
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/quotes"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.post(url, headers=headers)
8
​
9
print(response.text)



GetQuote
get
https://api.elections.kalshi.com/trade-api/v2/communications/quotes/{quote_id}
Endpoint for getting a particular quote

Path Params
quote_id
string
required
The ID of the quote to get.

Responses

200

400
Generic structure for API error responses.


403
Generic structure for API error responses.


404
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

CreateQuote
DeleteQuote
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/quotes/quote_id"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)



DeleteQuote
delete
https://api.elections.kalshi.com/trade-api/v2/communications/quotes/{quote_id}
Endpoint for deleting a quote, which means it can no longer be accepted.

Path Params
quote_id
string
required
The ID of the quote to delete.

Responses
204
No fields are returned on the response.


400
Generic structure for API error responses.


403
Generic structure for API error responses.


404
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

GetQuote
AcceptQuote
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/quotes/quote_id"
4
​
5
response = requests.delete(url)
6
​
7
print(response.text)



AcceptQuote
put
https://api.elections.kalshi.com/trade-api/v2/communications/quotes/{quote_id}/accept
Endpoint for accepting a quote. This will require the quoter to confirm

Path Params
quote_id
string
required
The quote being accepted.

Body Params
accepted_side
string
Responses
204
No fields are returned on the response.


400
Generic structure for API error responses.


403
Generic structure for API error responses.


404
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

DeleteQuote
ConfirmQuote
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/quotes/quote_id/accept"
4
​
5
headers = {"content-type": "application/json"}
6
​
7
response = requests.put(url, headers=headers)
8
​
9
print(response.text)



ConfirmQuote
put
https://api.elections.kalshi.com/trade-api/v2/communications/quotes/{quote_id}/confirm
Endpoint for confirming a quote. This will start a timer for order execution

Path Params
quote_id
string
required
The ID of the quote to confirm.

Responses
204
No fields are returned on the response.


400
Generic structure for API error responses.


403
Generic structure for API error responses.


404
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

AcceptQuote
GetRFQs
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/quotes/quote_id/confirm"
4
​
5
response = requests.put(url)
6
​
7
print(response.text)



GetRFQs
get
https://api.elections.kalshi.com/trade-api/v2/communications/rfqs
Endpoint for getting RFQs

Query Params
cursor
string
limit
int32
market_ticker
string
event_ticker
string
status
string
creator_user_id
string
Responses

200

400
Generic structure for API error responses.


403
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

ConfirmQuote
CreateRFQ
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/rfqs"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)



reateRFQ
post
https://api.elections.kalshi.com/trade-api/v2/communications/rfqs
Endpoint for creating a new RFQ

Query Params
market_ticker
string
contracts
int64
rest_remainder
boolean

Responses

200

400
Generic structure for API error responses.


403
Generic structure for API error responses.


409
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

GetRFQs
GetRFQ
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/rfqs"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.post(url, headers=headers)
8
​
9
print(response.text)



GetRFQ
get
https://api.elections.kalshi.com/trade-api/v2/communications/rfqs/{rfq_id}
Endpoint for getting a single RFQ by id

Path Params
rfq_id
string
required
The unique ID of the RFQ to get.

Responses

200

400
Generic structure for API error responses.


404
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

CreateRFQ
DeleteRFQ
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/rfqs/rfq_id"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)



DeleteRFQ
delete
https://api.elections.kalshi.com/trade-api/v2/communications/rfqs/{rfq_id}
Endpoint for deleting an RFQ by ID

Path Params
rfq_id
string
required
The ID of the RFQ to delete.

Responses
204
No fields are returned on the response.


403
Generic structure for API error responses.


404
Generic structure for API error responses.


409
Generic structure for API error responses.


500
Generic structure for API error responses.

Updated 3 months ago

GetRFQ
market
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/communications/rfqs/rfq_id"
4
​
5
response = requests.delete(url)
6
​
7
print(response.text)



GetEvents
get
https://api.elections.kalshi.com/trade-api/v2/events
Endpoint for getting data about all events.

Query Params
limit
int64
1 to 200
Parameter to specify the number of results per page. Defaults to 100.

cursor
string
The Cursor represents a pointer to the next page of records in the pagination.
So this optional parameter, when filled, should be filled with the cursor string returned in a previous request to this end-point.
Filling this would basically tell the api to get the next page containing the number of records passed on the limit parameter.
On the other side not filling it tells the api you want to get the first page for another query.
The cursor does not store any filters, so if any filter parameters like series_ticker was passed in the original query they must be passed again.

status
string
Restricts the events to those with certain statuses, as a comma separated list.
The following values are accepted: unopened, open, closed, settled.

series_ticker
string
Series ticker to retrieve contracts for.

with_nested_markets
boolean
If the markets belonging to the events should be added in the response as a nested field in this event.


Response

200
Updated 3 months ago

DeleteRFQ
GetEvent
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/events"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)



GetEvent
get
https://api.elections.kalshi.com/trade-api/v2/events/{event_ticker}
Endpoint for getting data about an event by its ticker.

Path Params
event_ticker
string
required
Should be filled with the ticker of the event.

Query Params
with_nested_markets
boolean
If the markets belonging to the events should be added in the response as a nested field in this event.


Response

200
Updated 3 months ago

GetEvents
GetMarkets
Did this page help you?
Language

Shell

Node

Ruby

PHP

Python
Request
python -m pip install requests
1
import requests
2
​
3
url = "https://api.elections.kalshi.com/trade-api/v2/events/event_ticker"
4
​
5
headers = {"accept": "application/json"}
6
​
7
response = requests.get(url, headers=headers)
8
​
9
print(response.text)

